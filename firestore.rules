/**
 * Core Philosophy: This ruleset implements a three-tiered access model for an e-commerce application.
 * 1. Public Data: The product catalog (products and categories) is publicly readable by anyone, but modifications are restricted to administrators.
 * 2. Private User Data: Customer profiles and order histories are strictly private. Data is segregated into user-specific document trees, and access is granted only to the data owner or an administrator.
 * 3. Administrative Roles: A separate collection (`roles_admin`) manages administrator privileges. The existence of a user's UID in this collection grants them elevated permissions across the database.
 *
 * Data Structure:
 * - `/categories/{categoryId}`: Public product categories.
 * - `/products/{productId}`: Public product listings.
 * - `/users/{userId}`: Root collection for all user-specific data.
 * - `/users/{userId}/orders/{orderId}`: A user's private order history.
 * - `/roles_admin/{uid}`: A lookup collection to identify administrators.
 *
 * Key Security Decisions:
 * - User Data Segregation: All user-specific data is nested under `/users/{userId}`, leveraging path-based security to ensure users can only access their own information. User listing is disabled to protect privacy.
 * - Admin Privilege Model: Admin access is determined by checking for the existence of a document in the `/roles_admin` collection. This is a simple, performant, and scalable way to manage roles without embedding role data in user documents.
 * - Public Catalog: The product catalog is intentionally left open for read access to allow unauthenticated users to browse, while write operations are locked down to admins to protect catalog integrity.
 *
 * Denormalization for Authorization:
 * - The primary denormalization pattern is the use of the `/roles_admin/{uid}` collection. Instead of querying for a role inside a user document, a simple and fast `exists()` check is used to grant admin privileges.
 * - User-owned documents (like Customer profiles and Orders) contain denormalized IDs (`id`, `customerId`) that are validated against the path parameters to ensure relational integrity during creation and updates.
 *
 * Structural Segregation:
 * - Public data (`/products`, `/categories`) is stored in separate top-level collections from private user data (`/users`). This clear separation simplifies rule logic, enhances security for list operations, and prevents accidental data leakage.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Checks if the user has an admin role by verifying document existence.
     * This is a performant way to manage global roles.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Checks if a user is either the owner of the resource or an admin.
     */
    function isOwnerOrAdmin(userId) {
      return isOwner(userId) || isAdmin();
    }
    
    /**
     * For state-changing operations (update, delete), checks that the document
     * exists and that the user is the owner or an admin.
     */
    function isExistingOwnerOrAdmin(userId) {
      return resource != null && isOwnerOrAdmin(userId);
    }
    
    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Publicly readable product categories. Writable only by admins.
     * @path /categories/{categoryId}
     * @allow (get) Any user, signed in or not, can read a category.
     * @deny (create) A signed-in, non-admin user cannot create a category.
     * @principle Public read access for catalog data, with centralized admin control for writes.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Publicly readable products. Writable only by admins.
     * @path /products/{productId}
     * @allow (list) Any user, signed in or not, can list all products.
     * @deny (update) A signed-in, non-admin user cannot update a product.
     * @principle Public read access for catalog data, with centralized admin control for writes.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description A user's profile document, containing customer information.
     * @path /users/{customerId}
     * @allow (create) A new user can create their own profile document if `auth.uid` matches `{customerId}`.
     * @deny (get) A user cannot read another user's profile document.
     * @deny (list) Listing users is forbidden to prevent user enumeration.
     * @principle Enforces strict data ownership and privacy for user profiles.
     */
    match /users/{customerId} {
      allow get: if isOwnerOrAdmin(customerId);
      allow list: if false;
      allow create: if isOwner(customerId) && request.resource.data.id == customerId;
      allow update: if isExistingOwnerOrAdmin(customerId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwnerOrAdmin(customerId);
    }

    /**
     * @description A user's orders, nested under their own document tree.
     * @path /users/{customerId}/orders/{orderId}
     * @allow (list) A signed-in user can list their own orders.
     * @allow (create) A user can create an order for themselves, ensuring the `customerId` field matches their ID.
     * @deny (get) A user cannot read an order belonging to another user.
     * @principle Path-based security ensures a user can only access their own order data.
     */
    match /users/{customerId}/orders/{orderId} {
      allow get, list: if isOwnerOrAdmin(customerId);
      allow create: if isOwnerOrAdmin(customerId) && request.resource.data.customerId == customerId;
      allow update: if isExistingOwnerOrAdmin(customerId) && request.resource.data.customerId == resource.data.customerId;
      allow delete: if isExistingOwnerOrAdmin(customerId);
    }
    
    /**
     * @description Items within a specific order. Inherits ownership from the parent order.
     * @path /users/{customerId}/orders/{orderId}/orderItems/{orderItemId}
     * @allow (get) The owner of the parent order can read the items within it.
     * @deny (list) A user cannot list order items belonging to another user's order.
     * @principle Inherited path-based security from the parent user and order documents.
     */
    match /users/{customerId}/orders/{orderId}/orderItems/{orderItemId} {
      allow get, list: if isOwnerOrAdmin(customerId);
      allow create: if isOwnerOrAdmin(customerId) && request.resource.data.orderId == orderId;
      allow update: if isExistingOwnerOrAdmin(customerId);
      allow delete: if isExistingOwnerOrAdmin(customerId);
    }

    /**
     * @description Admin role management. Document existence grants admin privileges.
     * @path /roles_admin/{uid}
     * @allow (create) An existing admin can grant admin rights to another user.
     * @deny (get) A non-admin user cannot read the admin list.
     * @principle Restricts modification of admin roles to other admins to prevent privilege escalation.
     */
    match /roles_admin/{uid} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
  }
}